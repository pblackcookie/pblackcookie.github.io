---
title: Java学习
date: 2022-08-30 17:40:21
categories: 
	- Learn
	- Java
tags: 
	- Java
---

&emsp;&emsp;学Java中，一些记录。

<!-- more -->


## 第三章
### Java数据类型
 重要！！必记选项
 ![](https://raw.githubusercontent.com/pblackcookie/ImageHosting/main/test-pic/202208191050472.png)


## 第四章
### 算术运算符
 
```java
//结果是多少,为什么?
int i = 1;  
i = i++;
System.out.println(i);

```

结果 i = 1;  
规则使用临时变量:  
1. temp = i ;  
2. i = i + 1; (自增的i)  
3. i = temp ;  

```java
// 结果是多少,为什么?
int i = 1;  
i = ++i;
System.out.println(i);

```

结果 i = 2;
规则使用临时变量:  
1. i = i + 1; (自增的i)     
2. temp = i ;  
3. i = temp ;  

```java
// 输出是多少?
int i1 = 10;
int i2 = 20;
int i = i1++; //i=10
System.out.println("i = " + i); //10
System.out.println("i2 = " + i2); //20
i = --i2;//i=19
System.out.println("i = " + i); //19
System.out.println("i2 = " + i2); //19

```
如图所示:  
![](https://raw.githubusercontent.com/pblackcookie/ImageHosting/main/test-pic/202208191154427.png)

### 逻辑运算符
两张图示:  
这里和模电不能说像,只能说一模一样。    
逻辑与&和短路与&&的区别:  
&:从左到右全部判断。  
&&:能判断结果就停止。  
![](https://raw.githubusercontent.com/pblackcookie/ImageHosting/main/test-pic/202208191248729.png)  
![](https://raw.githubusercontent.com/pblackcookie/ImageHosting/main/test-pic/202208191247305.png)  

### 原码,反码,补码 -- 重要
说来惭愧,这里笔者绝对学过,全 忘 了。  
0. 二进制  
1. 正数的原码,反码,补码都一样。  
2. 负数的反码=它的原码符号位不变,其它位取反。  
3. 负数的补码=它的反码+1, 负数的反码=负数的补码-1。  
4. 0的反码,补码都是0。  
5. java没有无符号数。  
6. **计算机运算的时候都是以补码的方式来运算的。**  
7. 看运算结果的时候看原码。(important)  

### 位运算符
开始感觉有意思了。  
![](https://raw.githubusercontent.com/pblackcookie/ImageHosting/main/test-pic/202208191717568.png)

### 第四章笔记重点记录

#### 算术运算符
/ % ++(前、后) --（前、后）  
数学公式和程序相结合（加小数点等：e.g.5/9改成5.0/9.0）  
**=（赋值）和 == （逻辑等于）是两个东西！！**  

#### 逻辑运算符
逻辑与短路的区别：  
逻辑：全都判断一遍  
短路：只要有一个满足/不满足条件就判断  
多用短路与/或，因为效率高。  
！取非 ：真变假，假变真。  
^逻辑异或：a与b不一样的时候，结果为真；否则为假。  

#### 赋值运算符
复合赋值运算符：  
a+=b ==> a = a + b  
a-=b ==> a = a - b  

#### 三元运算符
条件表达式 ? 表达式1 : 表达式2;  

### 标识符的规则和规范
标识符的规则和规范:  
标识符概念:变量,方法,类变量取名的那个叫标识符  

规则:  
1.由26个大小写字母,数字0-9,下划线_或$组成  
2.数字不能开头  
3.不能使用关键字或保留字,但可以包含关键字或保留字  
4.严格区分大小写,长度无限制  
5.标识符不能包含空格   

规范:(更加专业)  
1.包名:由多个单词组成时,所有单词小写  
2.类名,接口名:由多个单词组成时,所有单词首字母大写[大驼峰]  
3.变量名,方法名:由多个单词组成时,第一个单词首字母大写,第二个单词开始每个单词首字母大写[小驼峰]  
4.常量名:所有字母都大写,多个单词间用下划线连接  

### 进制介绍
2进制： 以0b或0B开头  
8进制： 以0开头  
10进制：0-9，满10进1   
16进制：以0x或者0X开头  

进制转换：无非是除除乘乘。

### 原码反码补码--重要
计算机用补码运算的原因：补码统一了正数和负数，使计算机的计算更加轻松。  
更多的上面记过了。

## 第五章笔记重点记录

### switch语句的穿透
穿透：满足条件后，执行对应语句块，判断有无break；  
没有break跳出switch语句，不用判断下一个常量，直接执行下一语句块。  
这就叫穿透现象。

### switch语句的细节讨论
1. 表达式（switch后）的数据类型，应该和case后的常量类型一致，或是可以自动转化。（例如char可以自动转化成int类型）  
2. swtich表达式中表达式的返回值必须是：（byte,short,int,char,enum[枚举]，String）  
3. case语句中的值必须是常量，或者是常量表达式，不能是变量。  
4. default语句是可选的，当没有匹配的case时，执行default;dafault+case都不匹配就无输出。  
5. break语句用来在执行一个case分支后跳出switch语句。没有写break，则穿透。

### switch和if的比较
1. 如果判断的具体数值不多，而且符合（byte,short,int,char,enum[枚举]，String），建议使用switch语句  
2. 对区间判断，对结果为boo lean类型判断，用if语句（if使用范围更广）  

### for循环细节注意事项
1. 循环条件是返回一个布尔值表达式（true or false）  
2. for循环初始化和变量迭代可以写到其他地方，但是“;”不能省略。  
   写在小括号里面，变量只在for循环中生效；写在小括号外面，变量全程序都能用。  
3. 循环初始值可以有多条初始化语句，要求类型一样，中间用逗号隔开；  
   循环变量迭代也可以有多条变量迭代句，中间用逗号隔开。  

## 编程思想
**化繁为简，先死后活。**  
1. 化繁为简： 将复杂的需求，拆解成简单的需求，逐步完成。  
2. 先死后活：先考虑固定的值，然后转成可以灵活变化的值。  

### while循环细节注意事项
1. 循环条件返回一个布尔值表达式。  
2. while循环先判断后执行。  

### while和do..while循环区别
while：先判断条件满足与否，再执行循环体内语句。  
do..while:无论条件满足与否，先执行一次循环体，随后再进行条件判断。  

### 多重循环控制--重难点
1. 含义:将一个循环放在另一个循环体内,形成嵌套循环;可读性问题: 建议一般只用两行(不要超过三行)  
2. 嵌套循环把内层循环当成外层循环的循环体.当只有内层循环条件为false时,才会跳出内层循环.e.g.外层循环m次,内层循环n次-->一共循环[m*n]次  
3. 经典题目:九九乘法表,空心金字塔等.

### 跳转控制语句-break
1. break语句出现在多层嵌套语句块时,可以通过**标签**指明要终止的是哪一层语句块.  
2. 标签名字由程序名指定 用法:break 标签名;  
3. 尽量不要使用标签.  
4. 如果没有指定break,默认退出最近的循环体.  

### 跳转控制语句-continue
1. 用于结束本次循环,继续进行下一次循环.  
2. 可以通过标签指明跳过哪一层循环.  

## 第六章
### 数组
数组可以存放多个同一类型的数据,也是一种数据类型,是引用类型.  
即:数组就是一组数据.
可以通过[数组名.length]得到数组的长度.  
### 数组细节
1. 数组内是多个**相同**数据类型的组合,不能混用.  
2. 数组中元素可以是任何数据类型,包括基本类型和引用类型.  
3. 数组创建后,如果没有赋值,有默认值: boolean:false;String:null;其他类型:0.  
4. 数组下标必须在指定范围内使用,否则会报:下标越界异常.  
5. 数组属于引用类型,数组型数据本质是对象.

### 数组赋值机制
数组在默认情况下是引用传递，赋值的是个地址；赋值方式叫做：地址拷贝  
图解：  
![](https://raw.githubusercontent.com/pblackcookie/ImageHosting/main/test-pic/202208211057794.png)

### 冒泡排序
通过对待排序序列从后向前，依次比较相邻元素的值，若发现则逆序交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒。  
一般是两个循环嵌套使用,并且添加一个临时变量temp,在排序时实现临时的值的保存。  

## 第七章--对象!!

### 属性
属性的定义语法同变量: 访问修饰符 属性类型 属性名;  
访问修饰符: 控制属性的访问范围
有四种访问修饰符:
1. public  
2. procected  
3. 默认  
4. private  

属性的定义类型可以为任意定义类型.  

属性如果不赋值,有默认值。规则和数组默认类型一样。

### 创建对象形式
1. 先声明再创建  
Cat cat; // 声明  
cat = new Cat();  // 创建空间  
2. 直接创建  
Cat cat = new Cat();  

### 方法
#### 方法调用小节
1. 当程序执行到方法时,会开辟一个独立的空间(栈空间)  
2. 当方法执行完毕,或者执行到return语句时,就会返回  
3. 返回到调用方法的地方  
4. 返回后继续执行方法后面的代码  
5. 当main方法(栈)执行完毕后,整个程序退出  

#### 成员方法定义
访问修饰符 返回数据类型 方法名(形参列表..){//方法体  
	语句;  
	return 返回值;  
}

#### 方法的细节

**返回数据类型**  
1. 一个方法最多只能有一个返回值;如何返回多个值? -->使用数组  
2. 返回值可以为任意类型,包括基本类型或引用类型  
3. 如果方法要求有返回数据类型,则必须有 return 值 语句,且要求返回值类型和return值的类型一致或兼容  
4. 如果方法为void,则方法体中可以不写return语句,或者只写return  
5. 方法名最好见名字知含义[遵守大驼峰]

**形参列表:**  
1. 一个方法可以有0个参数,也可有多个参数,中间用逗号隔开getSum(int n1, int n2)  
2. 参数类型可以为任意类型,包含基本类型或引用类型;e.g.printArr(int[][] map)  
3. 调用参数的方法一定对应参数列表传参相同类型或者兼容类型的参数  
4. 形参和实参的个数要相等,顺序一定要一一对应  

**方法体**  
1. 完成功能的具体语句,方法之中不能再定义一个方法. --> 禁止套娃!

**方法调用细节**  
1. 同一个类中的方法可以直接互相调用 --> A类的方法2要调用A类的方法1  
2. 跨类调用要通过对象名引用(先创建对象,再跨类调用即可) --> A类的方法2要调用B类的方法1  
3. 跨类的方法调用和方法的访问修饰符有关  

#### 递归调用
1. 执行一个方法时,就会创建一个新的受保护的独立空间(栈空间)  
2. 方法的局部变量是独立的  
3. 如果方法中使用的是引用类型,就会共享该引用类型的数据  
4. 递归必须向退出递归的条件无限逼近,否则会栈溢出  
5. 当一个方法执行完毕,或者return时,遵守谁调用就将结果返回给谁 <--> 当返回值后方法也就执行完毕  

### 方法重载(Overload)

java中允许同一个类中,多个重名方法的存在,但是要求形参列表不一致.  
这减轻了起名和记名的麻烦.  
细节:  
1. 方法名一样  
2. 方法的形参列表必须不一样  
3. 方法的返回类型无要求  

### 可变参数细节

1. 可变参数的实参可以为数组  
2. 可变参数的本质是数组  
3. 可变参数可以和普通参数一起在形参列表, 但必须保证可变参数在最后  
4. 一个形参列表中最多只能出现一个可变参数  

### 对象创建的流程分析

Person p = new Person("小倩",20);

1. 加载Person类信息(Person.class),只会加载一次  
2. 在堆中分配空间(得到一个地址信息)  
3. 完成对象(属性的)初始化[1.默认初始化 2.显式初始化 3.构造器的初始化]  
4. 再把对象在堆中的地址返回给p(p是对象名/也可理解成对象的引用)  

### this关键字

java虚拟机会给每个对象分配this,代表当前对象.  
哪个对象调用,this就代表哪个对象.  

#### 注意细节
1. this可以访问本类的属性,方法,构造器  
2. this用于区分当前的类属性和局部变量  
3. 访问成员方法的语法: this.方法名(参数列表);  
4. 访问构造器语法: this(参数列表) 只能在构造器中使用.注意: 如果有this访问构造器语法,这句语法必须放在第一条语句  
5. this不能在类定义的外部使用,只能在类定义的方法中使用  

## 第八章--开始使用IDEA

### 包
包的命名规则：只能包含数字，字母，下划线，小圆点  
不能数字开头，不能是关键字或保留字  
包的命名规范：  
1.	**一般是小写字母+小圆点**  
com.公司名.项目名.业务模块名  
com.sina.crm.user  -->用户模块  
com.sina.crm.order -->订单模块  
com.sina.crm.utils -->工具类  
2.	**常用的包**  
Java.long.* 基本包，无需引用，可以直接用  
Java.util.* 由系统提供的工具包  
Java.net.* 网络包 网络开发  
Java.awt.* 界面开发用（GUI）  

### 访问修饰符
Java有四种访问控制修饰符号，用于控制方法和属性的访问权限  
1.	公开级别：public 修饰 对外公开  
2.	受保护级别：protected修饰 对子类和同一个包  中的类公开  
3.	默认级别：没有修饰符，向同一个包的类公开  
4.	私有级别：private修饰 只有类本身可以访问，不对外公开   
 
**注意事项：**
1. 修饰符可以用来修饰类中的属性，成员方法及类  
2. 只有默认和public才能修饰类！且遵循访问权限特点  
3. 继承的学习后再讲解……  
4. 成员方法访问规则和属性完全一样  


### 面向对象三大特征 ： 封装、继承、多态

#### 封装： encapsulation
把抽象出来的数据【属性】和对数据的操作【方法】封装在一起，数据被保护在内部，程序其他部分只有通过被授权操作【方法】，才能对数据进行操作。  

封装好处：  
1. 隐藏实现的细节；方法（连接数据库）<-- 调用(传入参数)
2. 可以对数据进行验证，保证安全合理

封装实现步骤:  
1. 先对属性进行私有化private,让外部不能直接修改属性
2. 提供一个公共的(public)set方法,用于对属性判断并赋值
```java
Public void setXxx(类型,参数名){
//加入数据验证的业务逻辑
	属性= 参数名;
}
```

3. 提供一个公共的get方法,用于获取属性的值
```java
Public 数据类型 getXxx(){//权限判断 Xxx是某个属性
return xx;
}
```

封装： 将构造器 和 SetXxx结合

#### 继承： extends

为什么需要继承：
当业务逻辑一样时，两个类的属性和方法有很多是相同的，此时使用**继承**提高代码的复用性。

当多个类存在相同的属性（变量）时，可以将这些东西从子类中抽象出来形成父类。   
不同的子类只要通过关键字'extends'调用父类中的属性即可。  

继承基本语法：
```java
class 子类 extends 父类{

}
```

**想要用继承，必须使用关键字‘extends’！！**  

好处：  
1. 代码复用性提高
2. 代码拓展性和维护性提高了

##### 继承的细节
1. 子类继承了所有的属性和方法，但是私有属性和方法不能在子类直接去访问，要通过**父类**提供的公共方法去访问  
2. 子类必须调用父类的构造器完成父类的初始化(隐藏"super();",默认调用父类的无参构造器)
3. 当创造子类对象时，不管使用子类的哪个构造器,默认情况下总会调用父类的无参构造器.如果父类美欧提供无参构造器,则必须在子类的构造器中用super去指定使用父类的哪个构造器去完成对父类的初始化工作,否则编译不会通过
4. 如果希望指定去调用父类的某个构造器,则显示地调用一下: super(参数列表)
5. super在使用时,需要放在构造器第一行(super只能在构造器中使用)
6. super()和this()都只能放在构造器第一行,因此这两个方法不能共存在一个构造器
7. java所有类都是Object的子类,Object是所有类的基类
8. 父类构造器的调用不限于直接父类!将一直向上追溯直到Object类(顶级父类)
9. 子类最多只能继承一个父类(直接继承),即java中是单继承机制
10. 不能滥用继承,子类和父类之间必须满足 is-a 的逻辑关系

![](https://raw.githubusercontent.com/pblackcookie/ImageHosting/main/test-pic/202208251542136.png)

#### super关键字
super代表父类的引用,用于访问父类的属性,方法,构造器。  

1. 访问父类的属性，但不能访问父类的私有private属性。
   super.属性名;
2. 访问父类的方法，但不能访问父类的私有private方法。
   super.方法名(参数列表);
3. 访问父类的构造器：super.(参数列表);：只能放在构造器的第一句；只能出现一句。

##### super细节
1. 调用父类构造器的好处（分工明确，父类属性由父类初始化，子类属性由子类初始化）
2. 当属性中有子类和父类的成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super,this,直接访问是一样的效果。
e.g.:  
**this.function();** 从本类开始找function，没有找到则依次向上级寻找  
**super.function();** 直接跳过本类，依次向上级寻找function  

![](https://raw.githubusercontent.com/pblackcookie/ImageHosting/main/test-pic/202208251547254.png)

3. super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以用super去访问爷爷类的成员；如果多个基类中都有同名的成员，使用super访问遵循就近原则。  
 A --> B --> C  
 当然也需要遵守访问权限的相关规则。  

#### super VS. this
![](https://raw.githubusercontent.com/pblackcookie/ImageHosting/main/test-pic/202208251604789.png)

#### 方法重写-override
子类有一个方法和父类的某个方法的名称，返回类型，参数一样，那么子类的方法会覆盖父类的方法。  

##### override细节
1. 子类和父类的参数，方法名称要完全一样
2. 子类方法的返回类型和父类方法的返回类型一样，或是父类返回类型的子类
3. 子类方法不能缩小父类方法的访问权限，（但是可以扩大）

![](https://raw.githubusercontent.com/pblackcookie/ImageHosting/main/test-pic/202208251639999.png)


#### 多态：polymorphic

优点：多态能提高代码复用性，且利于代码维护。

多态是建立在封装和继承基础之上的。

##### 多态的具体体现
1. 方法的多态：重写和重载体现多态。
2. 对象的多态： **important**  
	(1)一个对象的编译类型和运行类型可以不一致  
	(2)编译类型在定义对象时，就确定了，不能改变  
	(3)运行类型是可以变化的  
	(4)编译类型看定义时 = 号的左边，运行类型看 = 号的右边  

##### 多态--> 向上转型 的本质
1. 本质： 父类的引用指向了子类的对象
2. 语法： 父类类型  引用名 = new 子类类型();
3. 特点:  
			(1)编译类型看左边,运行类型看右边  
			(2)可以调用父类中的所有成员(遵守访问权限)  
			(3)不能调用子类中特有成员;  

##### 多态--> 向下转型 的本质
1. 语法: **子类类型 引用名 = (子类类型) 父类引用;**
2. 只能强转父类的引用,不能强转父类对象
3. 要求 父类的引用必须指向的是当前目标类型的对象;(向下转型之前必须要有向上转型)
4. 可以调用子类类型中所有成员
5. 本质是 --> 使用子类对象

##### 多态 --> 注意细节
1. 属性没有重写之说,属性的值直接看编译类型
2. instanceof 比较操作符 用于判断对象的**运行**类型是否为XX类型或XX类型的子类型

##### java的动态绑定机制 **Important**
1. 当调用对象方法的时候，该方法会和该对象的内存地址/运行规则绑定
2. 当调用对象属性的时候，没有动态绑定机制，哪里声明哪里使用

### Object类详解

#### equals

equals 和 == 的区别：

**==：比较运算符**
1. 既可以判断基本类型，又可以判断引用类型
2. 判断基本类型，则判断值是否相等
3. 判断引用类型，判断引用的地址是否相等

**equals方法**
1. equals方法是Object类中的方法，只能判断引用类型
2. 默认判断地址是否相等

#### hashCode方法
1. 提高具有哈希结构的容器效率
2. 两个引用，如果指向同一个对象，则哈希值肯定是一样的
3. 两个引用，如果指向不同对象，则哈希值不一样
4. 哈希值主要根据地址计算，但不能完全将哈希值等价地址
5. 如果hashCode需要的话，也会重写

#### toString方法
默认返回：全类名 + @ + 哈希值的16进制    
子类往往重写toString方法，用于返回对象的属性信息   
重写toString方法 输出对象的属性（alt+insert里面就有）  
当直接输出一个对象时，toString方法会被默认调用

#### finalize方法
1. 当对象被回收时，系统自动调用该对象finalize方法，子类可以重写该方法，做一些释放资源的操作。
2. 什么时候被回收？ 当某个对象没有任何引用时，则jvm就任对这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象。在销毁该对象前，会先调用finalize方法
3. 垃圾回收机制的调用：是由系统来决定，也可以通过System。

**垃圾不是立马回收，程序有自己的垃圾回收算法**
主动触发： System.gc()
 我没有成功触发....

 ### 断点调试(debug)
 
 debug过程中,看的是对象的debug类型

 ![](https://raw.githubusercontent.com/pblackcookie/ImageHosting/main/test-pic/202208261640172.png)







## 参考学习资料
【零基础 快速学Java】韩顺平 零基础30天学会Java: https://www.bilibili.com/video/BV1fh411y7R8


